## API Report File for "html-validate"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { SchemaObject } from 'ajv';

// @public
export class Attribute {
    constructor(key: string, value: null | string | DynamicValue | null, keyLocation: Location_2, valueLocation: Location_2 | null, originalAttribute?: string);
    get isDynamic(): boolean;
    get isStatic(): boolean;
    readonly key: string;
    // (undocumented)
    readonly keyLocation: Location_2;
    // (undocumented)
    readonly originalAttribute?: string;
    // (undocumented)
    readonly value: string | DynamicValue | null;
    // (undocumented)
    readonly valueLocation: Location_2 | null;
    valueMatches(pattern: RegExp, dynamicMatches?: boolean): boolean;
    // (undocumented)
    valueMatches(pattern: string, dynamicMatches?: boolean): boolean;
    // (undocumented)
    valueMatches(pattern: string[], dynamicMatches?: boolean): boolean;
}

// @public
export interface AttributeData {
    key: string;
    originalAttribute?: string;
    quote: '"' | "'" | null;
    value: string | DynamicValue | null;
}

// @internal (undocumented)
export interface BaseToken {
    // (undocumented)
    location: Location_2;
    // (undocumented)
    type: TokenType;
}

// @public (undocumented)
export type CategoryOrTag = string;

// @public (undocumented)
interface CSSStyleDeclaration_2 {
    // (undocumented)
    [key: string]: string;
}
export { CSSStyleDeclaration_2 as CSSStyleDeclaration }

// @public (undocumented)
export interface DeprecatedElement {
    // (undocumented)
    documentation?: string;
    // (undocumented)
    message?: string;
    // (undocumented)
    source?: string;
}

// @public (undocumented)
export type DOMInternalID = number;

// @public (undocumented)
export class DOMNode {
    constructor(nodeType: NodeType, nodeName: string | undefined, location: Location_2);
    // (undocumented)
    append(node: DOMNode): void;
    // @internal
    blockRule(ruleId: string, blocker: RuleBlocker): void;
    // @internal
    blockRules(rules: string[] | Set<string>, blocker: RuleBlocker): void;
    // @internal
    cacheEnable(): void;
    cacheExists<K extends keyof DOMNodeCache>(key: K): boolean;
    // (undocumented)
    cacheExists(key: string | number | symbol): boolean;
    cacheGet<K extends keyof DOMNodeCache>(key: K): DOMNodeCache[K] | undefined;
    // (undocumented)
    cacheGet(key: string | number | symbol): any | undefined;
    cacheRemove<K extends keyof DOMNodeCache>(key: K): boolean;
    // (undocumented)
    cacheRemove(key: string | number | symbol): boolean;
    cacheSet<K extends keyof DOMNodeCache>(key: K, value: DOMNodeCache[K]): DOMNodeCache[K];
    // (undocumented)
    cacheSet<T>(key: string | number | symbol, value: T): T;
    // (undocumented)
    readonly childNodes: DOMNode[];
    // @internal
    disableRule(ruleId: string): void;
    // @internal
    disableRules(rules: string[] | Set<string>): void;
    enableRule(ruleId: string): void;
    enableRules(rules: string[]): void;
    get firstChild(): DOMNode;
    // (undocumented)
    generateSelector(): string | null;
    // (undocumented)
    isRootElement(): boolean;
    isSameNode(otherNode: DOMNode): boolean;
    get lastChild(): DOMNode;
    // (undocumented)
    readonly location: Location_2;
    // (undocumented)
    readonly nodeName: string;
    // (undocumented)
    readonly nodeType: NodeType;
    // @internal
    ruleBlockers(ruleId: string): RuleBlocker[];
    // @internal
    ruleEnabled(ruleId: string): boolean;
    get textContent(): string;
    // @internal (undocumented)
    readonly unique: DOMInternalID;
}

// @public (undocumented)
export interface DOMNodeCache {
}

// @public (undocumented)
class DOMTokenList_2 extends Array<string> {
    constructor(value: string | DynamicValue | null, location: Location_2 | null);
    // (undocumented)
    contains(token: string): boolean;
    // (undocumented)
    item(n: number): string | undefined;
    // (undocumented)
    iterator(): Generator<{
        index: number;
        item: string;
        location: Location_2;
    }>;
    // (undocumented)
    location(n: number): Location_2 | undefined;
    // (undocumented)
    readonly value: string;
}
export { DOMTokenList_2 as DOMTokenList }

// @public (undocumented)
export class DynamicValue {
    constructor(expr: string);
    // (undocumented)
    readonly expr: string;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export interface ElementTable {
    // (undocumented)
    [tagName: string]: MetaElement;
}

// @public (undocumented)
export interface FormAssociated {
    listed: boolean;
}

// @public (undocumented)
export class HtmlElement extends DOMNode {
    constructor(tagName: string | undefined, parent: HtmlElement | null, closed: NodeClosed, meta: MetaElement | null, location: Location_2);
    get annotatedName(): string;
    appendText(text: string | DynamicValue, location: Location_2): void;
    get ariaLabelledby(): string[] | DynamicValue | null;
    // (undocumented)
    protected readonly attr: {
        [key: string]: Attribute[];
    };
    get attributes(): Attribute[];
    get childElements(): HtmlElement[];
    get classList(): DOMTokenList_2;
    // (undocumented)
    closed: NodeClosed;
    closest(selectors: string): HtmlElement | null;
    // (undocumented)
    readonly depth: number;
    // @internal
    everyChildren(callback: (node: HtmlElement) => boolean): boolean;
    // @internal
    find(callback: (node: HtmlElement) => boolean): HtmlElement | null;
    get firstElementChild(): HtmlElement | null;
    // @internal (undocumented)
    static fromTokens(startToken: TagOpenToken, endToken: TagCloseToken, parent: HtmlElement | null, metaTable: MetaTable | null, namespace?: string): HtmlElement;
    generateSelector(): string | null;
    getAttribute(key: string): Attribute | null;
    // (undocumented)
    getAttribute(key: string, all: true): Attribute[];
    getAttributeValue(key: string): string | null;
    // (undocumented)
    getElementsByTagName(tagName: string): HtmlElement[];
    // (undocumented)
    hasAttribute(key: string): boolean;
    get id(): string | null;
    is(tagName: string): boolean;
    get lastElementChild(): HtmlElement | null;
    loadMeta(meta: MetaElement): void;
    matches(selector: string): boolean;
    // (undocumented)
    get meta(): MetaElement | null;
    // (undocumented)
    get nextSibling(): HtmlElement | null;
    // (undocumented)
    readonly parent: HtmlElement | null;
    // (undocumented)
    get previousSibling(): HtmlElement | null;
    // (undocumented)
    querySelector(selector: string): HtmlElement | null;
    // (undocumented)
    querySelectorAll(selector: string): HtmlElement[];
    // @internal (undocumented)
    static rootNode(location: Location_2): HtmlElement;
    setAnnotation(text: string): void;
    setAttribute(key: string, value: string | DynamicValue | null, keyLocation: Location_2, valueLocation: Location_2 | null, originalAttribute?: string): void;
    // (undocumented)
    get siblings(): HtmlElement[];
    // @internal
    someChildren(callback: (node: HtmlElement) => boolean): boolean;
    // (undocumented)
    get style(): CSSStyleDeclaration_2;
    // (undocumented)
    readonly tagName: string;
    // @internal
    visitDepthFirst(callback: (node: HtmlElement) => void): void;
    // (undocumented)
    readonly voidElement: boolean;
}

// @public (undocumented)
interface Location_2 {
    readonly column: number;
    readonly filename: string;
    readonly line: number;
    readonly offset: number;
    readonly size: number;
}
export { Location_2 as Location }

// @public (undocumented)
export interface MetaAttribute {
    // (undocumented)
    allowed?: MetaAttributeAllowedCallback;
    // (undocumented)
    boolean?: boolean;
    // (undocumented)
    deprecated?: boolean | string;
    // (undocumented)
    enum?: Array<string | RegExp>;
    // (undocumented)
    list?: boolean;
    // (undocumented)
    omit?: boolean;
    // (undocumented)
    required?: boolean;
}

// @public
export type MetaAttributeAllowedCallback = (node: HtmlElement, attr: Attribute) => string | null | undefined;

// @public (undocumented)
export interface MetaData {
    // (undocumented)
    attributes?: PermittedAttribute;
    // (undocumented)
    deprecated?: boolean | string | DeprecatedElement;
    // (undocumented)
    deprecatedAttributes?: string[];
    // (undocumented)
    embedded?: boolean | PropertyExpression;
    // (undocumented)
    flow?: boolean | PropertyExpression;
    // (undocumented)
    foreign?: boolean;
    // (undocumented)
    form?: boolean;
    formAssociated?: Partial<FormAssociated>;
    // (undocumented)
    heading?: boolean | PropertyExpression;
    // (undocumented)
    implicitClosed?: string[];
    // (undocumented)
    inherit?: string;
    // (undocumented)
    interactive?: boolean | PropertyExpression;
    // (undocumented)
    labelable?: boolean | PropertyExpression;
    // (undocumented)
    metadata?: boolean | PropertyExpression;
    // (undocumented)
    permittedContent?: Permitted;
    // (undocumented)
    permittedDescendants?: Permitted;
    // (undocumented)
    permittedOrder?: PermittedOrder;
    // (undocumented)
    permittedParent?: Permitted;
    // (undocumented)
    phrasing?: boolean | PropertyExpression;
    // (undocumented)
    requiredAncestors?: RequiredAncestors;
    // (undocumented)
    requiredAttributes?: string[];
    // (undocumented)
    requiredContent?: RequiredContent;
    // (undocumented)
    scriptSupporting?: boolean;
    // (undocumented)
    sectioning?: boolean | PropertyExpression;
    // (undocumented)
    textContent?: TextContent | `${TextContent}`;
    // (undocumented)
    transparent?: boolean | string[];
    // (undocumented)
    void?: boolean;
}

// @public (undocumented)
export interface MetaElement extends Omit<MetaData, "deprecatedAttributes" | "requiredAttributes"> {
    // (undocumented)
    attributes: Record<string, MetaAttribute>;
    // (undocumented)
    formAssociated?: FormAssociated;
    // (undocumented)
    tagName: string;
    // (undocumented)
    textContent?: TextContent;
}

// @public
export type MetaLookupableProperty = "metadata" | "flow" | "sectioning" | "heading" | "phrasing" | "embedded" | "interactive" | "deprecated" | "foreign" | "void" | "transparent" | "scriptSupporting" | "form" | "formAssociated" | "labelable";

// @public (undocumented)
export class MetaTable {
    // @internal
    constructor();
    // (undocumented)
    readonly elements: ElementTable;
    // @internal
    extendValidationSchema(patch: SchemaValidationPatch): void;
    // (undocumented)
    getJSONSchema(): SchemaObject;
    getMetaFor(tagName: string): MetaElement | null;
    getTagsDerivedFrom(tagName: string): string[];
    getTagsWithProperty(propName: MetaLookupableProperty): string[];
    // @internal (undocumented)
    init(): void;
    // @internal
    loadFromFile(filename: string): void;
    // @internal
    loadFromObject(obj: unknown, filename?: string | null): void;
    // @internal (undocumented)
    resolve(node: HtmlElement): void;
}

// @public (undocumented)
export enum NodeClosed {
    // (undocumented)
    EndTag = 1,
    // (undocumented)
    ImplicitClosed = 4,
    // (undocumented)
    Open = 0,
    // (undocumented)
    VoidOmitted = 2,
    // (undocumented)
    VoidSelfClosed = 3
}

// @public (undocumented)
export enum NodeType {
    // (undocumented)
    DOCUMENT_NODE = 9,
    // (undocumented)
    ELEMENT_NODE = 1,
    // (undocumented)
    TEXT_NODE = 3
}

// @public (undocumented)
export type Permitted = PermittedEntry[];

// @public (undocumented)
export type PermittedAttribute = Record<string, MetaAttribute | Array<string | RegExp> | null>;

// @public (undocumented)
export type PermittedEntry = CategoryOrTag | PermittedGroup | Array<CategoryOrTag | PermittedGroup>;

// @public (undocumented)
export interface PermittedGroup {
    // (undocumented)
    exclude?: string | string[];
}

// @public (undocumented)
export type PermittedOrder = string[];

// @public (undocumented)
export type ProcessAttributeCallback = (this: unknown, attr: AttributeData) => Iterable<AttributeData>;

// @public (undocumented)
export type ProcessElementCallback = (this: ProcessElementContext, node: HtmlElement) => void;

// @public (undocumented)
export interface ProcessElementContext {
    // (undocumented)
    getMetaFor(this: void, tagName: string): MetaElement | null;
}

// @public (undocumented)
export type PropertyExpression = string | [string, any];

// @public (undocumented)
export type RequiredAncestors = string[];

// @public (undocumented)
export type RequiredContent = string[];

// @internal (undocumented)
export type RuleBlocker = number & {
    __type: "rule-blocker";
};

// @public (undocumented)
export interface SchemaValidationPatch {
    // (undocumented)
    definitions?: Record<string, unknown>;
    // (undocumented)
    properties?: Record<string, unknown>;
}

// @public
export interface Source {
    column: number;
    // (undocumented)
    data: string;
    // (undocumented)
    filename: string;
    hooks?: SourceHooks;
    line: number;
    offset: number;
    originalData?: string;
    transformedBy?: string[];
}

// @public (undocumented)
export interface SourceHooks {
    processAttribute?: ProcessAttributeCallback | null;
    processElement?: ProcessElementCallback | null;
}

// @internal (undocumented)
export interface TagCloseToken extends BaseToken {
    // (undocumented)
    data: [text: ">" | "/>"];
    // (undocumented)
    type: TokenType.TAG_CLOSE;
}

// @internal (undocumented)
export interface TagOpenToken extends BaseToken {
    // (undocumented)
    data: [text: string, close: "/" | "", tag: string];
    // (undocumented)
    type: TokenType.TAG_OPEN;
}

// @public (undocumented)
export enum TextContent {
    // (undocumented)
    ACCESSIBLE = "accessible",
    // (undocumented)
    DEFAULT = "default",
    // (undocumented)
    NONE = "none",
    // (undocumented)
    REQUIRED = "required"
}

// @internal (undocumented)
export enum TokenType {
    // (undocumented)
    ATTR_NAME = 8,
    // (undocumented)
    ATTR_VALUE = 9,
    // (undocumented)
    COMMENT = 14,
    // (undocumented)
    CONDITIONAL = 15,
    // (undocumented)
    DIRECTIVE = 16,
    // (undocumented)
    DOCTYPE_CLOSE = 5,
    // (undocumented)
    DOCTYPE_OPEN = 3,
    // (undocumented)
    DOCTYPE_VALUE = 4,
    // (undocumented)
    EOF = 17,
    // (undocumented)
    SCRIPT = 12,
    // (undocumented)
    STYLE = 13,
    // (undocumented)
    TAG_CLOSE = 7,
    // (undocumented)
    TAG_OPEN = 6,
    // (undocumented)
    TEMPLATING = 11,
    // (undocumented)
    TEXT = 10,
    // (undocumented)
    UNICODE_BOM = 1,
    // (undocumented)
    WHITESPACE = 2
}

// @public (undocumented)
export interface TransformContext {
    chain(source: Source, filename: string): Iterable<Source>;
    hasChain(filename: string): boolean;
}

// @public (undocumented)
type Transformer_2 = (this: TransformContext, source: Source) => Iterable<Source>;
export { Transformer_2 as Transformer }

// @public
export function transformFile(fn: Transformer_2, filename: string, chain?: (source: Source, filename: string) => Iterable<Source>): Source[];

// @public
export function transformSource(fn: Transformer_2, source: Source, chain?: (source: Source, filename: string) => Iterable<Source>): Source[];

// @public
export function transformString(fn: Transformer_2, data: string, chain?: (source: Source, filename: string) => Iterable<Source>): Source[];

// (No @packageDocumentation comment for this package)

```
