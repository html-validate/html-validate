## API Report File for "html-validate"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ErrorObject } from 'ajv';
import { SchemaObject } from 'ajv';

// @public
export class Attribute {
    constructor(key: string, value: string | DynamicValue | null, keyLocation: Location_2, valueLocation: Location_2 | null, originalAttribute?: string);
    get isDynamic(): boolean;
    get isStatic(): boolean;
    readonly key: string;
    // (undocumented)
    readonly keyLocation: Location_2;
    // (undocumented)
    readonly originalAttribute?: string;
    // (undocumented)
    readonly value: string | DynamicValue | null;
    // (undocumented)
    readonly valueLocation: Location_2 | null;
    valueMatches(pattern: RegExp | string | string[], dynamicMatches?: boolean): boolean;
}

// @public
export interface AttributeData {
    key: string;
    originalAttribute?: string;
    quote: '"' | "'" | null;
    value: string | DynamicValue | null;
}

// @public
export interface AttributeEvent extends Event_2 {
    key: string;
    keyLocation: Location_2;
    location: Location_2;
    meta: MetaAttribute | null;
    originalAttribute?: string;
    quote: '"' | "'" | null;
    target: HtmlElement;
    value: string | DynamicValue | null;
    valueLocation: Location_2 | null;
}

// @internal (undocumented)
export interface AttrNameToken extends BaseToken {
    // (undocumented)
    data: [text: string, name: string];
    // (undocumented)
    type: TokenType.ATTR_NAME;
}

// @internal (undocumented)
export interface AttrValueToken extends BaseToken {
    // (undocumented)
    data: [text: string, delimiter: string, value: string, quote?: '"' | "'"];
    // (undocumented)
    type: TokenType.ATTR_VALUE;
}

// @public (undocumented)
export interface AvailableFormatters {
    // (undocumented)
    checkstyle: Formatter;
    // (undocumented)
    codeframe: Formatter;
    // (undocumented)
    json: Formatter;
    // (undocumented)
    stylish: Formatter;
    // (undocumented)
    text: Formatter;
}

// @internal (undocumented)
export interface BaseToken {
    // (undocumented)
    location: Location_2;
    // (undocumented)
    type: TokenType;
}

// @public (undocumented)
export type CategoryOrTag = string;

// @public
export function cjsResolver(options?: {
    rootDir?: string;
}): CommonJSResolver;

// @public
export function classifyNodeText(node: HtmlElement, options?: TextClassificationOptions): TextClassification;

// @public (undocumented)
export class CLI {
    constructor(options?: CLIOptions);
    clearCache(): void;
    expandFiles(patterns: string[], options?: ExpandOptions): string[];
    // @internal (undocumented)
    getConfig(): ConfigData;
    // (undocumented)
    getFormatter(formatters: string): (report: Report_2) => string;
    // @internal
    getLoader(): ConfigLoader;
    getValidator(): HtmlValidate;
    init(cwd: string): Promise<InitResult>;
    isIgnored(filename: string): boolean;
}

// @public (undocumented)
export interface CLIOptions {
    // (undocumented)
    configFile?: string;
    // (undocumented)
    rules?: string | string[];
}

// @internal (undocumented)
export interface CommentToken extends BaseToken {
    // (undocumented)
    data: [text: string, comment: string];
    // (undocumented)
    type: TokenType.COMMENT;
}

// @public
export type CommonJSResolver = Required<Resolver>;

// @public
export function compatibilityCheck(name: string, declared: string, options?: Partial<CompatibilityOptions>): boolean;

// @public
export interface CompatibilityOptions {
    logger(this: void, message: string): void;
    silent: boolean;
    // @internal
    version: string;
}

// @public
export interface ConditionalEvent extends Event_2 {
    condition: string;
    location: Location_2;
    parent: HtmlElement | null;
}

// @internal (undocumented)
export interface ConditionalToken extends BaseToken {
    // (undocumented)
    data: [text: string, condition: string];
    // (undocumented)
    type: TokenType.CONDITIONAL;
}

// @public
export class Config {
    static defaultConfig(): Config;
    static empty(): Config;
    // @internal
    static fromFile(resolvers: Resolver | Resolver[], filename: string): Config;
    static fromObject(resolvers: Resolver | Resolver[], options: ConfigData, filename?: string | null): Config;
    // @internal
    get(): ConfigData;
    // @internal
    getMetaTable(): MetaTable;
    // @internal
    getPlugins(): Plugin_2[];
    // @internal
    getRules(): Map<string, [Severity, RuleOptions]>;
    init(): void;
    isRootFound(): boolean;
    merge(resolvers: Resolver[], rhs: Config): Config;
    resolve(): ResolvedConfig;
    // @internal
    resolveData(): ResolvedConfigData;
    // @internal
    static validate(configData: ConfigData, filename?: string | null): void;
}

// @public (undocumented)
export interface ConfigData {
    elements?: Array<string | Record<string, unknown>>;
    extends?: string[];
    plugins?: Array<string | Plugin_2>;
    root?: boolean;
    // (undocumented)
    rules?: RuleConfig;
    transform?: TransformMap;
}

// @public (undocumented)
export class ConfigError extends UserError {
    constructor(message: string, nested?: Error);
}

// @public
export abstract class ConfigLoader {
    constructor(resolvers: Resolver[], config?: ConfigData);
    protected abstract defaultConfig(): Config;
    // (undocumented)
    protected empty(): Config;
    abstract flushCache(handle?: string): void;
    abstract getConfigFor(handle: string, configOverride?: ConfigData): ResolvedConfig;
    // @internal
    _getGlobalConfig(): ConfigData;
    // (undocumented)
    protected readonly globalConfig: Config;
    // (undocumented)
    protected loadFromFile(filename: string): Config;
    // (undocumented)
    protected loadFromObject(options: ConfigData, filename?: string | null): Config;
    // (undocumented)
    protected readonly resolvers: Resolver[];
}

// @internal (undocumented)
export const configPresets: Record<string, ConfigData>;

// @public
export interface ConfigReadyEvent extends Event_2 {
    // (undocumented)
    config: ResolvedConfig;
    // (undocumented)
    rules: Record<string, Rule<unknown, unknown>>;
}

// @public (undocumented)
type CSSStyleDeclaration_2 = Record<string, string>;
export { CSSStyleDeclaration_2 as CSSStyleDeclaration }

// @public (undocumented)
export interface DeferredMessage extends Omit<Message, "selector"> {
    // (undocumented)
    selector: () => string | null;
}

// @public
export function defineConfig(config: ConfigData): ConfigData;

// @public
export function defineMetadata(metatable: MetaDataTable): MetaDataTable;

// @public
export function definePlugin(plugin: Plugin_2): Plugin_2;

// @public (undocumented)
export interface DeprecatedElement {
    // (undocumented)
    documentation?: string;
    // (undocumented)
    message?: string;
    // (undocumented)
    source?: string;
}

// @public
export interface DirectiveEvent extends Event_2 {
    action: "enable" | "disable" | "disable-block" | "disable-next";
    actionLocation: Location_2;
    comment: string;
    commentLocation?: Location_2;
    data: string;
    location: Location_2;
    optionsLocation?: Location_2;
}

// @internal (undocumented)
export interface DirectiveToken extends BaseToken {
    // (undocumented)
    data: [text: string, begin: "[", action: string, delimiter: string, rest: string, end: "]" | ""];
    // (undocumented)
    type: TokenType.DIRECTIVE;
}

// @internal (undocumented)
export interface DoctypeCloseToken extends BaseToken {
    // (undocumented)
    data: [text: ">"];
    // (undocumented)
    type: TokenType.DOCTYPE_CLOSE;
}

// @public
export interface DoctypeEvent extends Event_2 {
    location: Location_2;
    tag: string;
    value: string;
    valueLocation: Location_2;
}

// @internal (undocumented)
export interface DoctypeOpenToken extends BaseToken {
    // (undocumented)
    data: [text: string, tag: string];
    // (undocumented)
    type: TokenType.DOCTYPE_OPEN;
}

// @internal (undocumented)
export interface DoctypeValueToken extends BaseToken {
    // (undocumented)
    data: [text: string];
    // (undocumented)
    type: TokenType.DOCTYPE_VALUE;
}

// @public (undocumented)
export type DOMInternalID = number;

// @public
export interface DOMLoadEvent extends Event_2 {
    // (undocumented)
    source: Source;
}

// @public (undocumented)
export class DOMNode {
    constructor(nodeType: NodeType, nodeName: string | undefined, location: Location_2);
    // (undocumented)
    append(node: DOMNode): void;
    // @internal
    blockRule(ruleId: string, blocker: RuleBlocker): void;
    // @internal
    blockRules(rules: string[] | Set<string>, blocker: RuleBlocker): void;
    // @internal
    cacheEnable(): void;
    cacheExists<K extends keyof DOMNodeCache>(key: K): boolean;
    // (undocumented)
    cacheExists(key: string | number | symbol): boolean;
    cacheGet<K extends keyof DOMNodeCache>(key: K): DOMNodeCache[K] | undefined;
    // (undocumented)
    cacheGet(key: string | number | symbol): any | undefined;
    cacheRemove<K extends keyof DOMNodeCache>(key: K): boolean;
    // (undocumented)
    cacheRemove(key: string | number | symbol): boolean;
    cacheSet<K extends keyof DOMNodeCache>(key: K, value: DOMNodeCache[K]): DOMNodeCache[K];
    // (undocumented)
    cacheSet<T>(key: string | number | symbol, value: T): T;
    // (undocumented)
    readonly childNodes: DOMNode[];
    // @internal
    disableRule(ruleId: string): void;
    // @internal
    disableRules(rules: string[] | Set<string>): void;
    enableRule(ruleId: string): void;
    enableRules(rules: string[]): void;
    get firstChild(): DOMNode;
    // (undocumented)
    generateSelector(): string | null;
    // (undocumented)
    isRootElement(): boolean;
    isSameNode(otherNode: DOMNode): boolean;
    get lastChild(): DOMNode;
    // (undocumented)
    readonly location: Location_2;
    // (undocumented)
    readonly nodeName: string;
    // (undocumented)
    readonly nodeType: NodeType;
    // @internal
    ruleBlockers(ruleId: string): RuleBlocker[];
    // @internal
    ruleEnabled(ruleId: string): boolean;
    get textContent(): string;
    // @internal (undocumented)
    readonly unique: DOMInternalID;
}

// @public (undocumented)
export interface DOMNodeCache {
}

// @public
export interface DOMReadyEvent extends Event_2 {
    document: DOMTree;
    // (undocumented)
    source: Source;
}

// @public (undocumented)
class DOMTokenList_2 extends Array<string> {
    constructor(value: string | DynamicValue | null, location: Location_2 | null);
    // (undocumented)
    contains(token: string): boolean;
    // (undocumented)
    item(n: number): string | undefined;
    // (undocumented)
    iterator(): Generator<{
        index: number;
        item: string;
        location: Location_2;
    }>;
    // (undocumented)
    location(n: number): Location_2 | undefined;
    // (undocumented)
    readonly value: string;
}
export { DOMTokenList_2 as DOMTokenList }

// @public (undocumented)
export class DOMTree {
    constructor(location: Location_2);
    // (undocumented)
    doctype: string | null;
    // (undocumented)
    find(callback: (node: HtmlElement) => boolean): HtmlElement | null;
    // (undocumented)
    getActive(): HtmlElement;
    // (undocumented)
    getElementsByTagName(tagName: string): HtmlElement[];
    // (undocumented)
    popActive(): void;
    // (undocumented)
    pushActive(node: HtmlElement): void;
    // (undocumented)
    querySelector(selector: string): HtmlElement | null;
    // (undocumented)
    querySelectorAll(selector: string): HtmlElement[];
    resolveMeta(table: MetaTable): void;
    // (undocumented)
    readonly root: HtmlElement;
    // (undocumented)
    visitDepthFirst(callback: (node: HtmlElement) => void): void;
}

// @public (undocumented)
export class DynamicValue {
    constructor(expr: string);
    // (undocumented)
    readonly expr: string;
    // (undocumented)
    toString(): string;
}

// @public
export interface ElementReadyEvent extends Event_2 {
    location: Location_2;
    target: HtmlElement;
}

// @internal (undocumented)
export interface EOFToken extends BaseToken {
    // (undocumented)
    data: [];
    // (undocumented)
    type: TokenType.EOF;
}

// @public (undocumented)
export interface ErrorDescriptor<ContextType> {
    // (undocumented)
    context?: ContextType;
    // (undocumented)
    location?: Location_2 | null | undefined;
    // (undocumented)
    message: string;
    // (undocumented)
    node: DOMNode | null;
}

// @public (undocumented)
interface Event_2 {
    location: Location_2 | null;
}
export { Event_2 as Event }

// @public (undocumented)
export type EventCallback = (event: string, data: any) => void;

// @internal (undocumented)
export interface EventDump {
    // (undocumented)
    data: any;
    // (undocumented)
    event: string;
}

// @public (undocumented)
export class EventHandler {
    constructor();
    on(event: string, callback: EventCallback): () => void;
    once(event: string, callback: EventCallback): () => void;
    trigger(event: string, data: any): void;
}

// @public (undocumented)
export interface ExpandOptions {
    cwd?: string;
    extensions?: string[];
}

// @public
export class FileSystemConfigLoader extends ConfigLoader {
    constructor(config?: ConfigData, options?: Partial<FileSystemConfigLoaderOptions>);
    constructor(resolvers: Resolver[], config?: ConfigData, options?: Partial<FileSystemConfigLoaderOptions>);
    // (undocumented)
    protected cache: Map<string, Config | null>;
    // (undocumented)
    protected defaultConfig(): Config;
    flushCache(filename?: string): void;
    fromFilename(filename: string): Config | null;
    getConfigFor(filename: string, configOverride?: ConfigData): ResolvedConfig;
    // @internal
    _getInternalCache(): Map<string, Config | null>;
}

// @public
export interface FileSystemConfigLoaderOptions {
    fs: FSLike;
}

// @public (undocumented)
export interface FormAssociated {
    listed: boolean;
}

// @public (undocumented)
export type Formatter = (results: Result[]) => string;

// @public
export function formatterFactory(name: keyof AvailableFormatters): Formatter;

// @public (undocumented)
export function formatterFactory(name: string): Formatter | null;

// @public (undocumented)
export interface FSLike {
    // (undocumented)
    existsSync(path: string): boolean;
}

// @public (undocumented)
export class HtmlElement extends DOMNode {
    constructor(tagName: string | undefined, parent: HtmlElement | null, closed: NodeClosed, meta: MetaElement | null, location: Location_2);
    // @internal (undocumented)
    readonly _adapter: HtmlElementLike;
    get annotatedName(): string;
    appendText(text: string | DynamicValue, location: Location_2): void;
    get ariaLabelledby(): string[] | DynamicValue | null;
    // (undocumented)
    protected readonly attr: Record<string, Attribute[]>;
    get attributes(): Attribute[];
    get childElements(): HtmlElement[];
    get classList(): DOMTokenList_2;
    // (undocumented)
    closed: NodeClosed;
    closest(selectors: string): HtmlElement | null;
    // (undocumented)
    readonly depth: number;
    // @internal
    everyChildren(callback: (node: HtmlElement) => boolean): boolean;
    // @internal
    find(callback: (node: HtmlElement) => boolean): HtmlElement | null;
    get firstElementChild(): HtmlElement | null;
    // @internal (undocumented)
    static fromTokens(startToken: TagOpenToken, endToken: TagCloseToken, parent: HtmlElement | null, metaTable: MetaTable | null, namespace?: string): HtmlElement;
    generateSelector(): string | null;
    getAttribute(key: string): Attribute | null;
    // (undocumented)
    getAttribute(key: string, all: true): Attribute[];
    getAttributeValue(key: string): string | null;
    // (undocumented)
    getElementsByTagName(tagName: string): HtmlElement[];
    // (undocumented)
    hasAttribute(key: string): boolean;
    get id(): string | null;
    is(tagName: string): boolean;
    get lastElementChild(): HtmlElement | null;
    loadMeta(meta: MetaElement): void;
    matches(selector: string): boolean;
    // (undocumented)
    get meta(): MetaElement | null;
    // (undocumented)
    get nextSibling(): HtmlElement | null;
    // (undocumented)
    readonly parent: HtmlElement | null;
    // (undocumented)
    get previousSibling(): HtmlElement | null;
    // (undocumented)
    querySelector(selector: string): HtmlElement | null;
    // (undocumented)
    querySelectorAll(selector: string): HtmlElement[];
    // @internal (undocumented)
    static rootNode(location: Location_2): HtmlElement;
    setAnnotation(text: string): void;
    setAttribute(key: string, value: string | DynamicValue | null, keyLocation: Location_2, valueLocation: Location_2 | null, originalAttribute?: string): void;
    // (undocumented)
    get siblings(): HtmlElement[];
    // @internal
    someChildren(callback: (node: HtmlElement) => boolean): boolean;
    // (undocumented)
    get style(): CSSStyleDeclaration_2;
    // (undocumented)
    readonly tagName: string;
    // @internal
    visitDepthFirst(callback: (node: HtmlElement) => void): void;
    // (undocumented)
    readonly voidElement: boolean;
}

// @public
export interface HtmlElementLike {
    // (undocumented)
    closest(selectors: string): HtmlElementLike | null | undefined;
    // (undocumented)
    getAttribute(name: string): string | DynamicValue | null | undefined;
    // (undocumented)
    hasAttribute(name: string): boolean;
}

// @public
export class HtmlValidate {
    constructor(config?: ConfigData);
    constructor(configLoader: ConfigLoader);
    canValidate(filename: string): Promise<boolean>;
    canValidateSync(filename: string): boolean;
    // (undocumented)
    protected configLoader: ConfigLoader;
    // @internal
    dumpEvents(filename: string): EventDump[];
    // @internal
    dumpSource(filename: string): string[];
    // @internal
    dumpTokens(filename: string): TokenDump[];
    // @internal
    dumpTree(filename: string): string[];
    flushConfigCache(filename?: string): void;
    getConfigFor(filename: string, configOverride?: ConfigData): Promise<ResolvedConfig>;
    getConfigForSync(filename: string, configOverride?: ConfigData): ResolvedConfig;
    getConfigurationSchema(): SchemaObject;
    getContextualDocumentation(message: Pick<Message, "ruleId" | "context">, filename?: string): Promise<RuleDocumentation | null>;
    getContextualDocumentation(message: Pick<Message, "ruleId" | "context">, config: ResolvedConfig | Promise<ResolvedConfig>): Promise<RuleDocumentation | null>;
    getContextualDocumentationSync(message: Pick<Message, "ruleId" | "context">, filename?: string): RuleDocumentation | null;
    getContextualDocumentationSync(message: Pick<Message, "ruleId" | "context">, config: ResolvedConfig): RuleDocumentation | null;
    getElementsSchema(filename?: string): Promise<SchemaObject>;
    getElementsSchemaSync(filename?: string): SchemaObject;
    // @internal
    getParserFor(source: Source): Promise<Parser>;
    // @deprecated
    getRuleDocumentation(ruleId: string, config?: ResolvedConfig | Promise<ResolvedConfig> | null, context?: unknown | null): Promise<RuleDocumentation | null>;
    // @deprecated
    getRuleDocumentationSync(ruleId: string, config?: ResolvedConfig | null, context?: unknown | null): RuleDocumentation | null;
    validateFile(filename: string): Promise<Report_2>;
    validateFileSync(filename: string): Report_2;
    validateMultipleFiles(filenames: string[]): Promise<Report_2>;
    validateMultipleFilesSync(filenames: string[]): Report_2;
    validateSource(input: Source, configOverride?: ConfigData): Promise<Report_2>;
    validateSourceSync(input: Source, configOverride?: ConfigData): Report_2;
    validateString(str: string): Promise<Report_2>;
    // (undocumented)
    validateString(str: string, filename: string): Promise<Report_2>;
    // (undocumented)
    validateString(str: string, hooks: SourceHooks): Promise<Report_2>;
    // (undocumented)
    validateString(str: string, options: ConfigData): Promise<Report_2>;
    // (undocumented)
    validateString(str: string, filename: string, hooks: SourceHooks): Promise<Report_2>;
    // (undocumented)
    validateString(str: string, filename: string, options: ConfigData): Promise<Report_2>;
    // (undocumented)
    validateString(str: string, filename: string, options: ConfigData, hooks: SourceHooks): Promise<Report_2>;
    validateStringSync(str: string): Report_2;
    // (undocumented)
    validateStringSync(str: string, filename: string): Report_2;
    // (undocumented)
    validateStringSync(str: string, hooks: SourceHooks): Report_2;
    // (undocumented)
    validateStringSync(str: string, options: ConfigData): Report_2;
    // (undocumented)
    validateStringSync(str: string, filename: string, hooks: SourceHooks): Report_2;
    // (undocumented)
    validateStringSync(str: string, filename: string, options: ConfigData): Report_2;
    // (undocumented)
    validateStringSync(str: string, filename: string, options: ConfigData, hooks: SourceHooks): Report_2;
}

// @public (undocumented)
export interface IncludeExcludeOptions {
    // (undocumented)
    exclude: string[] | null;
    // (undocumented)
    include: string[] | null;
}

// @public (undocumented)
export interface InitResult {
    // (undocumented)
    filename: string;
}

// @internal (undocumented)
export function keywordPatternMatcher(list: string[], keyword: string): boolean;

// @public (undocumented)
export interface ListenEventMap {
    // (undocumented)
    "*": Event_2;
    // (undocumented)
    "config:ready": ConfigReadyEvent;
    // (undocumented)
    "dom:load": DOMLoadEvent;
    // (undocumented)
    "dom:ready": DOMReadyEvent;
    // (undocumented)
    "element:ready": ElementReadyEvent;
    // @internal (undocumented)
    "parse:begin": ParseBeginEvent;
    // @internal (undocumented)
    "parse:end": ParseEndEvent;
    // @internal (undocumented)
    "rule:error": RuleErrorEvent;
    // (undocumented)
    "source:ready": SourceReadyEvent;
    // (undocumented)
    "tag:close": TagCloseEvent;
    // (undocumented)
    "tag:end": TagEndEvent;
    // (undocumented)
    "tag:open": TagOpenEvent;
    // (undocumented)
    "tag:ready": TagReadyEvent;
    // (undocumented)
    "tag:start": TagStartEvent;
    // (undocumented)
    attr: AttributeEvent;
    // (undocumented)
    conditional: ConditionalEvent;
    // (undocumented)
    directive: DirectiveEvent;
    // (undocumented)
    doctype: DoctypeEvent;
    // @internal (undocumented)
    token: TokenEvent;
    // (undocumented)
    whitespace: WhitespaceEvent;
}

// @internal
export interface LoadedPlugin extends Plugin_2 {
    // (undocumented)
    name: string;
    // (undocumented)
    originalName: string;
}

// @public (undocumented)
interface Location_2 {
    readonly column: number;
    readonly filename: string;
    readonly line: number;
    readonly offset: number;
    readonly size: number;
}
export { Location_2 as Location }

// @public
export interface Message {
    column: number;
    context?: any;
    line: number;
    message: string;
    offset: number;
    ruleId: string;
    ruleUrl?: string;
    selector: string | null;
    severity: number;
    size: number;
}

// @public (undocumented)
export interface MetaAttribute {
    allowed?: MetaAttributeAllowedCallback;
    boolean?: boolean;
    deprecated?: boolean | string;
    enum?: Array<string | RegExp>;
    list?: boolean;
    omit?: boolean;
    required?: boolean;
}

// @public
export type MetaAttributeAllowedCallback = (node: HtmlElementLike, attr: string | DynamicValue | null | undefined) => string | null | undefined;

// @public
export const MetaCopyableProperty: Array<keyof MetaElement>;

// @public (undocumented)
export interface MetaData {
    // (undocumented)
    attributes?: PermittedAttribute;
    // (undocumented)
    deprecated?: boolean | string | DeprecatedElement;
    // (undocumented)
    deprecatedAttributes?: string[];
    // (undocumented)
    embedded?: boolean | PropertyExpression;
    // (undocumented)
    flow?: boolean | PropertyExpression;
    focusable?: boolean | MetaFocusableCallback;
    // (undocumented)
    foreign?: boolean;
    // (undocumented)
    form?: boolean;
    formAssociated?: Partial<FormAssociated>;
    // (undocumented)
    heading?: boolean | PropertyExpression;
    // (undocumented)
    implicitClosed?: string[];
    // (undocumented)
    implicitRole?: MetaImplicitRoleCallback;
    // (undocumented)
    inherit?: string;
    // (undocumented)
    interactive?: boolean | PropertyExpression;
    // (undocumented)
    labelable?: boolean | PropertyExpression;
    // (undocumented)
    metadata?: boolean | PropertyExpression;
    // (undocumented)
    permittedContent?: Permitted;
    // (undocumented)
    permittedDescendants?: Permitted;
    // (undocumented)
    permittedOrder?: PermittedOrder;
    // (undocumented)
    permittedParent?: Permitted;
    // (undocumented)
    phrasing?: boolean | PropertyExpression;
    // (undocumented)
    requiredAncestors?: RequiredAncestors;
    // (undocumented)
    requiredAttributes?: string[];
    // (undocumented)
    requiredContent?: RequiredContent;
    // (undocumented)
    scriptSupporting?: boolean;
    // (undocumented)
    sectioning?: boolean | PropertyExpression;
    // (undocumented)
    textContent?: TextContent | `${TextContent}`;
    // (undocumented)
    transparent?: boolean | string[];
    // (undocumented)
    void?: boolean;
}

// @public
export interface MetadataHelper {
    allowedIfAttributeHasValue(this: void, attr: string, value: string[], options?: {
        defaultValue?: string | null;
    }): MetaAttributeAllowedCallback;
    allowedIfAttributeIsAbsent(this: void, ...attr: string[]): MetaAttributeAllowedCallback;
    allowedIfAttributeIsPresent(this: void, ...attr: string[]): MetaAttributeAllowedCallback;
    allowedIfParentIsPresent(this: void, ...tags: string[]): MetaAttributeAllowedCallback;
}

// @public (undocumented)
export const metadataHelper: MetadataHelper;

// @public (undocumented)
export type MetaDataTable = Record<string, MetaData>;

// @public (undocumented)
export interface MetaElement extends Omit<MetaData, "deprecatedAttributes" | "requiredAttributes"> {
    // (undocumented)
    attributes: Record<string, MetaAttribute>;
    // (undocumented)
    focusable: boolean | MetaFocusableCallback;
    // (undocumented)
    formAssociated?: FormAssociated;
    // (undocumented)
    implicitRole: MetaImplicitRoleCallback;
    // (undocumented)
    tagName: string;
    // (undocumented)
    textContent?: TextContent;
}

// @public
export type MetaFocusableCallback = (node: HtmlElementLike) => boolean;

// @public
export type MetaImplicitRoleCallback = (node: HtmlElementLike) => string | null;

// @public
export type MetaLookupableProperty = "metadata" | "flow" | "sectioning" | "heading" | "phrasing" | "embedded" | "interactive" | "deprecated" | "foreign" | "void" | "transparent" | "scriptSupporting" | "focusable" | "form" | "formAssociated" | "labelable";

// @public (undocumented)
export class MetaTable {
    // @internal
    constructor();
    extendValidationSchema(patch: SchemaValidationPatch): void;
    // (undocumented)
    getJSONSchema(): SchemaObject;
    getMetaFor(tagName: string): MetaElement | null;
    getTagsDerivedFrom(tagName: string): string[];
    getTagsWithProperty(propName: MetaLookupableProperty): string[];
    // @internal (undocumented)
    init(): void;
    loadFromObject(obj: unknown, filename?: string | null): void;
    // @internal (undocumented)
    resolve(node: HtmlElement): void;
}

// @public (undocumented)
export class NestedError extends Error {
    constructor(message: string, nested?: Error);
}

// @public (undocumented)
export enum NodeClosed {
    // (undocumented)
    EndTag = 1,//            element wasn't closed
    // (undocumented)
    ImplicitClosed = 4,//          element closed with end tag <p>...</p>
    // (undocumented)
    Open = 0,//     void element with omitted end tag <input>
    // (undocumented)
    VoidOmitted = 2,//  self-closed void element <input/>
    // (undocumented)
    VoidSelfClosed = 3
}

// @public @deprecated
export type NodeJSResolver = Required<Resolver>;

// @public @deprecated
export function nodejsResolver(options?: {
    rootDir?: string;
}): NodeJSResolver;

// @public (undocumented)
export enum NodeType {
    // (undocumented)
    DOCUMENT_NODE = 9,
    // (undocumented)
    ELEMENT_NODE = 1,
    // (undocumented)
    TEXT_NODE = 3
}

// @internal
export interface ParseBeginEvent extends Event_2 {
    // (undocumented)
    location: null;
}

// @internal
export interface ParseEndEvent extends Event_2 {
    // (undocumented)
    location: null;
}

// @public
export class Parser {
    constructor(config: ResolvedConfig);
    // @internal (undocumented)
    protected consumeDirective(token: DirectiveToken): void;
    // @internal (undocumented)
    protected consumeTag(source: Source, startToken: TagOpenToken, tokenStream: TokenStream): void;
    // @internal
    protected consumeUntil(tokenStream: TokenStream, search: TokenType, errorLocation: Location_2): IterableIterator<Token>;
    // @internal
    defer(cb: () => void): void;
    // @internal (undocumented)
    getEventHandler(): EventHandler;
    on<K extends keyof ListenEventMap>(event: K, listener: (event: string, data: ListenEventMap[K]) => void): () => void;
    // (undocumented)
    on(event: string, listener: EventCallback): () => void;
    once<K extends keyof ListenEventMap>(event: K, listener: (event: string, data: ListenEventMap[K]) => void): () => void;
    // (undocumented)
    once(event: string, listener: EventCallback): () => void;
    parseHtml(source: string | Source): HtmlElement;
    // @internal
    trigger<K extends keyof TriggerEventMap>(event: K, data: TriggerEventMap[K]): void;
}

// @public (undocumented)
export type Permitted = PermittedEntry[];

// @public (undocumented)
export type PermittedAttribute = Record<string, MetaAttribute | Array<string | RegExp> | null>;

// @public (undocumented)
export type PermittedEntry = CategoryOrTag | PermittedGroup | Array<CategoryOrTag | PermittedGroup>;

// @public (undocumented)
export interface PermittedGroup {
    // (undocumented)
    exclude?: string | string[];
}

// @public (undocumented)
export type PermittedOrder = string[];

// @public (undocumented)
interface Plugin_2 {
    configs?: Record<string, ConfigData | null> | null;
    elementSchema?: SchemaValidationPatch | null;
    init?(): void;
    name?: string | null;
    rules?: Record<string, RuleConstructor<any, any> | null> | null;
    setup?(source: Source, eventhandler: EventHandler): void;
    transformer?: Transformer_2 | Record<string, Transformer_2 | null> | null;
}
export { Plugin_2 as Plugin }

// @public (undocumented)
export type ProcessAttributeCallback = (this: unknown, attr: AttributeData) => Iterable<AttributeData>;

// @public (undocumented)
export type ProcessElementCallback = (this: ProcessElementContext, node: HtmlElement) => void;

// @public (undocumented)
export interface ProcessElementContext {
    // (undocumented)
    getMetaFor(this: void, tagName: string): MetaElement | null;
}

// @public (undocumented)
export type PropertyExpression = string | [string, any];

// @public
interface Report_2 {
    errorCount: number;
    results: Result[];
    valid: boolean;
    warningCount: number;
}
export { Report_2 as Report }

// @public (undocumented)
export class Reporter {
    constructor();
    // (undocumented)
    add<ContextType, OptionsType>(rule: Rule<ContextType, OptionsType>, message: string, severity: number, node: DOMNode | null, location: Location_2, context: ContextType): void;
    // (undocumented)
    addManual(filename: string, message: DeferredMessage): void;
    // (undocumented)
    protected isValid(): boolean;
    static merge(reports: Report_2[]): Report_2;
    static merge(reports: Promise<Report_2[]> | Array<Promise<Report_2>>): Promise<Report_2>;
    // (undocumented)
    protected result: Record<string, DeferredMessage[]>;
    // (undocumented)
    save(sources?: Source[]): Report_2;
}

// @public (undocumented)
export type RequiredAncestors = string[];

// @public (undocumented)
export type RequiredContent = string[];

// @public
export class ResolvedConfig {
    // @internal
    constructor({ metaTable, plugins, rules, transformers }: ResolvedConfigData, original: ConfigData);
    canTransform(filename: string): boolean;
    getConfigData(): ConfigData;
    // (undocumented)
    getMetaTable(): MetaTable;
    // (undocumented)
    getPlugins(): Plugin_2[];
    // (undocumented)
    getRules(): Map<string, [Severity, RuleOptions]>;
    transformFilename(filename: string): Source[];
    transformSource(source: Source, filename?: string): Source[];
}

// @public (undocumented)
export interface ResolvedConfigData {
    // (undocumented)
    metaTable: MetaTable;
    // (undocumented)
    plugins: Plugin_2[];
    // (undocumented)
    rules: Map<string, [Severity, RuleOptions]>;
    // (undocumented)
    transformers: TransformerEntry[];
}

// @public (undocumented)
export interface Resolver {
    name: string;
    resolveConfig?(id: string, options: ResolverOptions): ConfigData | null;
    resolveElements?(id: string, options: ResolverOptions): MetaDataTable | null;
    resolvePlugin?(id: string, options: ResolverOptions): Plugin_2 | null;
    resolveTransformer?(id: string, options: ResolverOptions): Transformer_2 | null;
}

// @public (undocumented)
export interface ResolverOptions {
    // (undocumented)
    cache: boolean;
}

// @public (undocumented)
export interface Result {
    // (undocumented)
    errorCount: number;
    // (undocumented)
    filePath: string;
    // (undocumented)
    messages: Message[];
    // (undocumented)
    source: string | null;
    // (undocumented)
    warningCount: number;
}

// @public (undocumented)
export abstract class Rule<ContextType = void, OptionsType = void> {
    constructor(options: OptionsType);
    // @internal
    block(id: RuleBlocker): void;
    get deprecated(): boolean;
    // @virtual
    documentation(context: ContextType): RuleDocumentation | null;
    // @internal
    getBlockers(node?: DOMNode | null): RuleBlocker[];
    getMetaFor(tagName: string): MetaElement | null;
    // (undocumented)
    getSeverity(): Severity;
    getTagsDerivedFrom(tagName: string): string[];
    getTagsWithProperty(propName: MetaLookupableProperty): string[];
    // @internal
    init(parser: Parser, reporter: Reporter, severity: number, meta: MetaTable): void;
    // @internal
    isBlocked(node?: DOMNode | null): boolean;
    // @internal
    isEnabled(node?: DOMNode | null): boolean;
    isKeywordIgnored<T extends IncludeExcludeOptions>(this: {
        options: T;
    }, keyword: string, matcher?: (list: string[], it: string) => boolean): boolean;
    name: string;
    on<K extends keyof ListenEventMap>(event: K, callback: (event: ListenEventMap[K]) => void): () => void;
    // (undocumented)
    on<K extends keyof ListenEventMap>(event: K, filter: (event: ListenEventMap[K]) => boolean, callback: (event: ListenEventMap[K]) => void): () => void;
    readonly options: OptionsType;
    report(error: ErrorDescriptor<ContextType>): void;
    // (undocumented)
    report(node: DOMNode | null, message: string, location?: Location_2 | null | undefined): void;
    // (undocumented)
    report(node: DOMNode | null, message: string, location: Location_2 | null | undefined, context: ContextType): void;
    static schema(): SchemaObject | null | undefined;
    // (undocumented)
    setEnabled(enabled: boolean): void;
    // (undocumented)
    setServerity(severity: Severity): void;
    abstract setup(): void;
    // @internal
    unblock(id: RuleBlocker): void;
    // @internal
    static validateOptions(cls: RuleConstructor<unknown, unknown> | undefined, ruleId: string, jsonPath: string, options: unknown, filename: string | null, config: ConfigData): void;
}

// @internal (undocumented)
export type RuleBlocker = number & {
    __type: "rule-blocker";
};

// @public (undocumented)
export type RuleConfig = Record<string, RuleSeverity | [RuleSeverity] | [RuleSeverity, RuleOptions]>;

// @public (undocumented)
export interface RuleConstructor<T, U> {
    // (undocumented)
    new (options?: any): Rule<T, U>;
    // (undocumented)
    schema(): SchemaObject | null | undefined;
}

// @public (undocumented)
export interface RuleDocumentation {
    // (undocumented)
    description: string;
    // (undocumented)
    url?: string;
}

// @internal
export interface RuleErrorEvent extends Event_2 {
    blockers: RuleBlocker[];
    enabled: boolean;
    // (undocumented)
    ruleId: string;
}

// @public
export function ruleExists(ruleId: string): boolean;

// @public (undocumented)
export type RuleOptions = string | number | Record<string, any>;

// @public (undocumented)
export type RuleSeverity = "off" | "warn" | "error" | number;

export { SchemaObject }

// @public (undocumented)
export class SchemaValidationError extends UserError {
    constructor(filename: string | null, message: string, obj: unknown, schema: SchemaObject, errors: ErrorObject[]);
    readonly errors: ErrorObject[];
    readonly filename: string | null;
    readonly obj: unknown;
    readonly schema: SchemaObject;
}

// @public (undocumented)
export interface SchemaValidationPatch {
    // (undocumented)
    definitions?: Record<string, unknown>;
    // (undocumented)
    properties?: Record<string, unknown>;
}

// @internal (undocumented)
export interface ScriptToken extends BaseToken {
    // (undocumented)
    data: [text: string];
    // (undocumented)
    type: TokenType.SCRIPT;
}

// @public (undocumented)
export enum Severity {
    // (undocumented)
    DISABLED = 0,
    // (undocumented)
    ERROR = 2,
    // (undocumented)
    WARN = 1
}

// @public
export function sliceLocation(location: Location_2, begin: number, end?: number, wrap?: string): Location_2;

// @public (undocumented)
export function sliceLocation(location: Location_2 | null | undefined, begin: number, end?: number, wrap?: string): Location_2 | null;

// @public
export interface Source {
    column: number;
    // (undocumented)
    data: string;
    // (undocumented)
    filename: string;
    hooks?: SourceHooks;
    line: number;
    offset: number;
    originalData?: string;
    transformedBy?: string[];
}

// @public (undocumented)
export interface SourceHooks {
    processAttribute?: ProcessAttributeCallback | null;
    processElement?: ProcessElementCallback | null;
}

// @public
export interface SourceReadyEvent extends Event_2 {
    // (undocumented)
    source: Source;
}

// @public
export class StaticConfigLoader extends ConfigLoader {
    constructor(config?: ConfigData);
    constructor(resolvers: Resolver[], config?: ConfigData);
    // (undocumented)
    protected defaultConfig(): Config;
    // (undocumented)
    flushCache(): void;
    // (undocumented)
    getConfigFor(_handle: string, configOverride?: ConfigData): ResolvedConfig;
}

// @public
export interface StaticResolver extends Required<Resolver> {
    // (undocumented)
    addConfig(id: string, config: ConfigData): void;
    // (undocumented)
    addElements(id: string, elements: MetaDataTable): void;
    // (undocumented)
    addPlugin(id: string, plugin: Plugin_2): void;
    // (undocumented)
    addTransformer(id: string, transformer: Transformer_2): void;
}

// @public
export function staticResolver(map?: StaticResolverMap): StaticResolver;

// @public
export interface StaticResolverMap {
    // (undocumented)
    configs?: Record<string, ConfigData>;
    // (undocumented)
    elements?: Record<string, MetaDataTable>;
    // (undocumented)
    plugins?: Record<string, Plugin_2>;
    // (undocumented)
    transformers?: Record<string, Transformer_2>;
}

// @internal (undocumented)
export interface StyleToken extends BaseToken {
    // (undocumented)
    data: [text: string];
    // (undocumented)
    type: TokenType.STYLE;
}

// @public @deprecated
export type TagCloseEvent = TagEndEvent;

// @internal (undocumented)
export interface TagCloseToken extends BaseToken {
    // (undocumented)
    data: [text: ">" | "/>"];
    // (undocumented)
    type: TokenType.TAG_CLOSE;
}

// @public
export interface TagEndEvent extends Event_2 {
    location: Location_2;
    previous: HtmlElement;
    target: HtmlElement | null;
}

// @public @deprecated
export type TagOpenEvent = TagStartEvent;

// @internal (undocumented)
export interface TagOpenToken extends BaseToken {
    // (undocumented)
    data: [text: string, close: "/" | "", tag: string];
    // (undocumented)
    type: TokenType.TAG_OPEN;
}

// @public
export interface TagReadyEvent extends Event_2 {
    location: Location_2;
    target: HtmlElement;
}

// @public
export interface TagStartEvent extends Event_2 {
    location: Location_2;
    target: HtmlElement;
}

// @internal (undocumented)
export interface TemplatingToken extends BaseToken {
    // (undocumented)
    data: [text: string];
    // (undocumented)
    type: TokenType.TEMPLATING;
}

// @public (undocumented)
export enum TextClassification {
    // (undocumented)
    DYNAMIC_TEXT = 1,
    // (undocumented)
    EMPTY_TEXT = 0,
    // (undocumented)
    STATIC_TEXT = 2
}

// @public (undocumented)
export interface TextClassificationOptions {
    accessible?: boolean;
    ignoreHiddenRoot?: boolean;
}

// @public (undocumented)
export enum TextContent {
    // (undocumented)
    ACCESSIBLE = "accessible",
    // (undocumented)
    DEFAULT = "default",
    // (undocumented)
    NONE = "none",
    // (undocumented)
    REQUIRED = "required"
}

// @public
export class TextNode extends DOMNode {
    constructor(text: string | DynamicValue, location: Location_2);
    get isDynamic(): boolean;
    get isStatic(): boolean;
    get textContent(): string;
}

// @internal (undocumented)
export interface TextToken extends BaseToken {
    // (undocumented)
    data: [text: string];
    // (undocumented)
    type: TokenType.TEXT;
}

// @internal (undocumented)
export type Token = UnicodeBOMToken | WhitespaceToken | DoctypeOpenToken | DoctypeValueToken | DoctypeCloseToken | TagOpenToken | TagCloseToken | AttrNameToken | AttrValueToken | TextToken | TemplatingToken | ScriptToken | StyleToken | CommentToken | ConditionalToken | DirectiveToken | EOFToken;

// @internal (undocumented)
export interface TokenDump {
    // (undocumented)
    data: string;
    // (undocumented)
    location: string;
    // (undocumented)
    token: string;
}

// @internal
export interface TokenEvent extends Event_2 {
    // @deprecated (undocumented)
    data?: any;
    // (undocumented)
    token: Token;
    // @deprecated (undocumented)
    type: TokenType;
}

// @internal (undocumented)
export type TokenStream = IterableIterator<Token>;

// @internal (undocumented)
export enum TokenType {
    // (undocumented)
    ATTR_NAME = 8,
    // (undocumented)
    ATTR_VALUE = 9,
    // (undocumented)
    COMMENT = 14,
    // (undocumented)
    CONDITIONAL = 15,
    // (undocumented)
    DIRECTIVE = 16,
    // (undocumented)
    DOCTYPE_CLOSE = 5,
    // (undocumented)
    DOCTYPE_OPEN = 3,
    // (undocumented)
    DOCTYPE_VALUE = 4,
    // (undocumented)
    EOF = 17,
    // (undocumented)
    SCRIPT = 12,
    // (undocumented)
    STYLE = 13,
    // (undocumented)
    TAG_CLOSE = 7,
    // (undocumented)
    TAG_OPEN = 6,
    // (undocumented)
    TEMPLATING = 11,
    // (undocumented)
    TEXT = 10,
    // (undocumented)
    UNICODE_BOM = 1,
    // (undocumented)
    WHITESPACE = 2
}

// @public (undocumented)
export interface TransformContext {
    chain(source: Source, filename: string): Iterable<Source>;
    hasChain(filename: string): boolean;
}

// @public
interface Transformer_2 {
    (this: TransformContext, source: Source): Iterable<Source>;
    api?: number;
}
export { Transformer_2 as Transformer }

// @public (undocumented)
export interface TransformerEntry {
    // (undocumented)
    fn: Transformer_2;
    // (undocumented)
    name: string;
    // (undocumented)
    pattern: RegExp;
}

// @public (undocumented)
export type TransformMap = Record<string, string>;

// @public (undocumented)
export interface TriggerEventMap {
    // (undocumented)
    "config:ready": ConfigReadyEvent;
    // (undocumented)
    "dom:load": DOMLoadEvent;
    // (undocumented)
    "dom:ready": DOMReadyEvent;
    // (undocumented)
    "element:ready": ElementReadyEvent;
    // @internal (undocumented)
    "parse:begin": ParseBeginEvent;
    // @internal (undocumented)
    "parse:end": ParseEndEvent;
    // @internal (undocumented)
    "rule:error": RuleErrorEvent;
    // (undocumented)
    "source:ready": SourceReadyEvent;
    // (undocumented)
    "tag:end": TagEndEvent;
    // (undocumented)
    "tag:ready": TagReadyEvent;
    // (undocumented)
    "tag:start": TagStartEvent;
    // (undocumented)
    attr: AttributeEvent;
    // (undocumented)
    conditional: ConditionalEvent;
    // (undocumented)
    directive: DirectiveEvent;
    // (undocumented)
    doctype: DoctypeEvent;
    // @internal (undocumented)
    token: TokenEvent;
    // (undocumented)
    whitespace: WhitespaceEvent;
}

// @internal (undocumented)
export interface UnicodeBOMToken extends BaseToken {
    // (undocumented)
    data: [bom: string];
    // (undocumented)
    type: TokenType.UNICODE_BOM;
}

// @public (undocumented)
export class UserError extends NestedError {
    constructor(message: string, nested?: Error);
    // (undocumented)
    prettyFormat(): string | undefined;
}

// @public
export class Validator {
    static validateAncestors(node: HtmlElement, rules: RequiredAncestors | null): boolean;
    static validateAttribute(attr: Attribute, rules: Record<string, MetaAttribute>): boolean;
    static validateOccurrences(children: HtmlElement[], rules: Permitted | null, cb: (node: HtmlElement, category: string) => void): boolean;
    static validateOrder(children: HtmlElement[], rules: PermittedOrder | null, cb: (node: HtmlElement, prev: HtmlElement) => void): boolean;
    static validatePermitted(node: HtmlElement, rules: Permitted | null): boolean;
    static validatePermittedCategory(node: HtmlElement, category: string, defaultMatch: boolean): boolean;
    static validateRequiredContent(node: HtmlElement, rules: RequiredContent | null): CategoryOrTag[];
}

// @public (undocumented)
export const version: string;

// @public
export interface WhitespaceEvent extends Event_2 {
    location: Location_2;
    text: string;
}

// @internal (undocumented)
export interface WhitespaceToken extends BaseToken {
    // (undocumented)
    data: [text: string];
    // (undocumented)
    type: TokenType.WHITESPACE;
}

// @public
export class WrappedError<T> extends Error {
    constructor(message: T);
}

// (No @packageDocumentation comment for this package)

```
